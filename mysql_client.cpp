//
// Created by dingrui on 2024/7/12.
//

#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <iostream>

#include "mysql_client.h"
#include "packet.h"
#include "mysql_macros.h"
#include "payload.h"

#define ARR_LEN 1024

MySQLClient::MySQLClient(const std::string& host,
	uint16_t port,
	const std::string& username,
	const std::string& pwd,
	const std::string& db_name)
	: host(host), port(port), username(username), pwd(pwd), db_name(db_name), sock(0)
{
}

MySQLClient::~MySQLClient()
{
	if (this->sock > 0)
	{
		std::cout << "close the tcp connect, fd=" << this->sock << "\n";
		close(this->sock);
	}
}

int MySQLClient::connect_to_server()
{
	if ((this->sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
	{
		std::cerr << "socket create err\n";
		return false;
	}
	struct sockaddr_in serv_addr;
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(this->port);
	if (inet_pton(AF_INET, this->host.c_str(), &serv_addr.sin_addr) <= 0)
	{
		std::cerr << "invalid addr, not supported\n";
		return false;
	}
	if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0)
	{
		std::cerr << "connect failed\n";
		return false;
	}
	std::cout << "connect to mysql server\n";
	return true;
}

bool MySQLClient::receive_handshake_packet(MySQLPacket& packet)
{
	std::vector<uint8_t> buf(ARR_LEN);
	ssize_t bytes_received = recv(this->sock, buf.data(), buf.size(), 0);
	if (bytes_received < 0)
	{
		std::cerr << "fail to receive handshake packet\n";
		return false;
	}
	buf.resize(bytes_received);
#ifdef TEST_DEBUG
	// 握手包的原始数据
	std::cout << "服务端发送的初始握手包原始数据: ";
	for (const auto& byte : buf)
	{
		std::cout << std::hex << static_cast<int>(byte) << " ";
	}
	std::cout << std::dec << std::endl;
#endif
	// 解析握手包
	packet.read(buf);
	HandshakeV10Payload* handshake_v10_packet = (HandshakeV10Payload*)packet.payload;
	this->server_capabilities =
		(handshake_v10_packet->capability_flags_2 << 16) | handshake_v10_packet->capability_flags_1;
#ifdef TEST_DEBUG
	std::cout << "服务端capabilities值为0x" << std::hex << this->server_capabilities << std::dec << std::endl;
#endif
	return true;
}
bool MySQLClient::send_handshake_response()
{
	std::vector<uint8_t> resp_data;
	if (this->server_capabilities & CLIENT_PROTOCOL_41)
	{
		HandshakeResponse41 resp(this->username, this->pwd, this->db_name, this->server_capabilities);
		resp.client_flag = CLIENT_PROTOCOL_41 | CLIENT_PLUGIN_AUTH;
		resp.max_packet_size = 0xffffffff;
		resp.character_set = 0x21;
		for (int i = 0; i < 23; i++)
		{
			resp.filler.push_back(0x00);
		}
		resp.username = this->username;
		if (this->server_capabilities & CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA)
		{
			// string<length>	auth_response	opaque authentication response data generated by Authentication Method indicated by the plugin name field.
			// TODO: 2024/7/20
		}
		else
		{
			// int<1>	auth_response_length	length of auth_response
			// string<length>	auth_response	opaque authentication response data generated by Authentication Method indicated by the plugin name field.
		}
		if (this->server_capabilities & CLIENT_CONNECT_WITH_DB)
		{
			// string<NUL>	database	initial database for the connection. This string should be interpreted using the character set indicated by character set field.
			// 数据库名
		}
		// int<1>	zstd_compression_level	compression level for zstd compression algorithm
		resp_data = resp.write();
	}
	else
	{
		HandshakeResponse320 resp;
		// TODO: 2024/7/20
		resp_data = resp.write();
	}
#ifdef TEST_DEBUG
	// 响应握手包的原始数据
	std::cout << "客户端回复握手包的原始数据: ";
	for (const auto& byte : resp_data)
	{
		std::cout << std::hex << static_cast<int>(byte) << " ";
	}
	std::cout << std::dec << std::endl;
#endif
	// send系统函数的第4个参数flags
	// #define MSG_OOB        0x1  /* process out-of-band data */
	// #define MSG_DONTROUTE  0x4  /* bypass routing, use direct interface */
	if (send(this->sock, resp_data.data(), resp_data.size(), 0) < 0)
	{
		std::cerr << "客户端发送握手包失败\n";
		return false;
	}
	std::cout << "客户端发送握手包成功\n";
	return true;
}