//
// Created by dingrui on 2024/7/12.
//

#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <iostream>
#include <functional>
#include <iomanip>

#include "include/mysql_client.h"
#include "include/packet.h"
#include "include/mysql_macros.h"
#include "include/payload.h"

#define ARR_LEN 1024

MySQLClient::MySQLClient(const std::string& host,
	uint16_t port,
	const std::string& username,
	const std::string& pwd,
	const std::string& db_name)
	: host(host), port(port), username(username), pwd(pwd), db_name(db_name), sock(0)
{
}

MySQLClient::~MySQLClient()
{
	if (this->sock > 0)
	{
		std::cout << "close the tcp connect, fd=" << this->sock << "\n";
		close(this->sock);
	}
}

int MySQLClient::connect_to_server()
{
	if ((this->sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
	{
		std::cerr << "socket create err\n";
		return false;
	}
	struct sockaddr_in serv_addr;
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(this->port);
	if (inet_pton(AF_INET, this->host.c_str(), &serv_addr.sin_addr) <= 0)
	{
		std::cerr << "invalid addr, not supported\n";
		return false;
	}
	if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0)
	{
		std::cerr << "connect failed\n";
		return false;
	}
	std::cout << "connect to mysql server\n";
	return true;
}

int MySQLClient::recv_packet(MySQLPacket& packet, std::function<void(void*)> const& fn)
{
	std::vector<uint8_t> buf(ARR_LEN);
	ssize_t bytes_received = recv(this->sock, buf.data(), buf.size(), 0);
	if (bytes_received < 0)
	{
		std::cerr << "接收服务端数据失败\n";
		return false;
	}
	buf.resize(bytes_received);
#ifdef TEST_DEBUG
	// 客户端收到服务端的字节数组
	std::cout << "服务端发送的原始数据: ";
	for (const auto& byte : buf)
	{
		std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<uint32_t>(byte) << " ";
	}
	std::cout << std::dec << std::endl;
#endif
	// 解析服务端数据
	packet.read(buf, fn);
#ifdef TEST_DEBUG
	std::cout << "服务端capabilities值为0x" << std::hex << std::setw(8) << std::setfill('0')
			  << this->server_capabilities << std::endl;
	std::cout << std::dec;
#endif
	return true;
}
bool MySQLClient::send_handshake_response()
{
	std::vector<uint8_t> resp_data;
	if (this->server_capabilities & CLIENT_PROTOCOL_41)
	{
		HandshakeResponse41
			handshake_response_payload(this->username, this->pwd, this->db_name, this->server_capabilities);
		handshake_response_payload.client_flag = CLIENT_PROTOCOL_41 | CLIENT_PLUGIN_AUTH;
		handshake_response_payload.max_packet_size = 0xffffffff;
		handshake_response_payload.character_set = 0x21;
		for (int i = 0; i < 23; i++)
		{
			handshake_response_payload.filler.push_back(0x00);
		}
		handshake_response_payload.username = this->username;
		if (this->server_capabilities & CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA)
		{
			// string<length>	auth_response	opaque authentication response data generated by Authentication Method indicated by the plugin name field.
			// TODO: 2024/7/20
		}
		else
		{
			// int<1>	auth_response_length	length of auth_response
			// string<length>	auth_response	opaque authentication response data generated by Authentication Method indicated by the plugin name field.
		}
		if (this->server_capabilities & CLIENT_CONNECT_WITH_DB)
		{
			// string<NUL>	database	initial database for the connection. This string should be interpreted using the character set indicated by character set field.
			// 数据库名
		}
		// int<1>	zstd_compression_level	compression level for zstd compression algorithm
		MySQLPacket handshake_resp_packet(&handshake_response_payload);
		return this->send_packet(handshake_resp_packet);
	}
	else
	{
		HandshakeResponse320 resp;
		// TODO: 2024/7/20
		resp_data = resp.write();
	}
	return true;
}
bool MySQLClient::send_packet(MySQLPacket& packet)
{
	std::vector<uint8_t> packet_data = packet.write();
#ifdef TEST_DEBUG
	std::cout << "客户端发送的原始数据为: " << std::hex;
	for (const auto& byte : packet_data)
	{
		std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<uint32_t>(byte) << " ";
	}
	std::cout << std::dec << std::endl;
#endif
	// send系统函数的第4个参数flags
	// #define MSG_OOB        0x1  /* process out-of-band data */
	// #define MSG_DONTROUTE  0x4  /* bypass routing, use direct interface */
	if (send(this->sock, packet_data.data(), packet_data.size(), 0) < 0)
	{
		std::cerr << "客户端发送数据包失败\n";
		return false;
	}
	std::cout << "客户端发送数据包成功\n";
	return true;
}
