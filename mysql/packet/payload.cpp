//
// Created by dingrui on 2024/7/14.
//

#include <iostream>

#include "../include/payload.h"
#include "../include/util.h"
#include "../include/mysql_macros.h"

void Payload::print()
{
}
void Payload::read(const std::vector<uint8_t>& buffer)
{

}
std::vector<uint8_t> Payload::write()
{
	return {};
}
void HandshakeV9Payload::print()
{
	// TODO: 2024/7/20
}
void HandshakeV9Payload::read(const std::vector<uint8_t>& buffer)
{
	// TODO: 2024/7/20
}
void HandshakeV10Payload::print()
{
	std::cout << "protocol version: " << static_cast<uint32_t>(this->protocol_version) << "\n";
	std::cout << "connection id: " << static_cast<uint32_t>(this->connection_id) << "\n";
	std::cout << "filler: " << static_cast<uint32_t>(this->filler) << "\n";
	std::cout << "capability_flags_1: " << static_cast<uint32_t>(this->capability_flags_1) << "\n";
	std::cout << "character_set: " << static_cast<uint32_t>(this->character_set) << "\n";
	std::cout << "status_flags: " << static_cast<uint32_t>(this->status_flags) << "\n";
	std::cout << "capability_flags_2: " << static_cast<uint32_t>(this->capability_flags_2) << "\n";
	std::cout << "auth_plugin_data_len: " << static_cast<uint32_t>(this->auth_plugin_data_len) << "\n";
	std::cout << "auth_plugin_name: " << this->auth_plugin_name << "\n";
}
void HandshakeV10Payload::read(const std::vector<uint8_t>& buffer)
{
	size_t i = 4;
	this->protocol_version = ParserUtil::read_int_from_byte_arr<uint8_t>(buffer, i);
	this->server_version = ParserUtil::read_string_till_terminate(buffer, i);
	this->connection_id = ParserUtil::read_int_from_byte_arr<uint32_t>(buffer, i);
	this->auth_plugin_data_part_1 = ParserUtil::read_n_bytes(buffer, i, 8);
	this->filler = ParserUtil::read_int_from_byte_arr<uint8_t>(buffer, i);
	this->capability_flags_1 = ParserUtil::read_int_from_byte_arr<uint16_t>(buffer, i);
	this->character_set = ParserUtil::read_int_from_byte_arr<uint8_t>(buffer, i);
	this->status_flags = ParserUtil::read_int_from_byte_arr<uint16_t>(buffer, i);
	this->capability_flags_2 = ParserUtil::read_int_from_byte_arr<uint16_t>(buffer, i);
	int capability_flags = (this->capability_flags_2 << 16) | this->capability_flags_1;
	if (capability_flags & CLIENT_PLUGIN_AUTH)
		this->auth_plugin_data_len = ParserUtil::read_int_from_byte_arr<uint8_t>(buffer, i);
	else this->auth_plugin_data_len = 0;
	this->reserved = ParserUtil::read_n_bytes(buffer, i, 10);
	this->auth_plugin_data_part_2 =
		ParserUtil::read_n_bytes(buffer, i, std::max(13, static_cast<int>(this->auth_plugin_data_len) - 8));
	if (capability_flags & CLIENT_PLUGIN_AUTH)
	{
		// caching_sha2_password
		this->auth_plugin_name = ParserUtil::read_string_till_terminate(buffer, i);
	}
}
void HandshakeResponse320::print()
{
	// TODO: 2024/7/20
}
std::vector<uint8_t> HandshakeResponse320::write()
{
	// TODO: 2024/7/20
	return {};
}
std::vector<uint8_t> HandshakeResponse320::generate_auth_response(const std::string& password,
	const std::vector<unsigned char>& nonce)
{
	// TODO: 2024/7/20
	return {};
}
HandshakeResponse41::HandshakeResponse41(const std::string& username,
	const std::string& pwd,
	const std::string& db_name,
	uint32_t server_capabilities)
	: username(username), pwd(pwd), database(db_name), server_capabilities(server_capabilities)
{

}
void HandshakeResponse41::print()
{
	// TODO: 2024/7/20
}
std::vector<uint8_t> HandshakeResponse41::write()
{
	// 小端序 认证权限数据
	std::vector<uint8_t> handshake_resp;
	for (int i = 0; i < 4; i++)
	{
		handshake_resp.push_back((this->client_flag >> (i * 8)) & 0xff);
	}
	for (int i = 0; i < 4; i++)
	{
		handshake_resp.push_back((this->max_packet_size >> (i * 8)) & 0xff);
	}
	handshake_resp.push_back(this->character_set);
	size_t len = this->filler.length();
	for (size_t i = 0; i < len; i++)
	{
		handshake_resp.push_back(this->filler.at(i));
	}
	handshake_resp.insert(handshake_resp.end(), this->username.begin(), this->username.end());
	handshake_resp.push_back(0x00);
	if (this->server_capabilities & CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA)
	{
		// string<length>	auth_response	opaque authentication response data generated by Authentication Method indicated by the plugin name field.
		handshake_resp.insert(handshake_resp.end(), this->auth_response.begin(), this->auth_response.end());
	}
	else
	{
		// int<1>	auth_response_length	length of auth_response
		handshake_resp.push_back(this->auth_response_length);
		// string<length>	auth_response	opaque authentication response data generated by Authentication Method indicated by the plugin name field.
		handshake_resp.insert(handshake_resp.end(), this->auth_response.begin(), this->auth_response.end());
	}
	if (this->server_capabilities & CLIENT_CONNECT_WITH_DB)
	{
		// string<NUL>	database	initial database for the connection. This string should be interpreted using the character set indicated by character set field.
		// 数据库名
		handshake_resp.insert(handshake_resp.end(), this->database.begin(), this->database.end());
		// 字符串结束符null
		handshake_resp.push_back(0x00);
	}
	if (this->server_capabilities & CLIENT_CONNECT_ATTRS)
	{
		// int<lenenc>	length of all key-values	affected rows
		// string<lenenc>	key1	Name of the 1st client attribute
		// string<lenenc>	value1	Value of the 1st client attribute
	}
	// int<1>	zstd_compression_level	compression level for zstd compression algorithm
	return handshake_resp;
}
std::vector<uint8_t> HandshakeResponse41::generate_auth_response(const std::string& password,
	const std::vector<unsigned char>& nonce)
{
	// TODO: 2024/7/20
	return {};
}
void OkPayload::print()
{

}
void OkPayload::read(const std::vector<uint8_t>& buffer)
{

}
void ErrPayload::print()
{
}
void ErrPayload::read(const std::vector<uint8_t>& buffer)
{
}